<!DOCTYPE html>
<!-- @author mrdoob -->
<!-- @author quinnciccoretti -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>three.js webvr - htc vive - paint</title>
		
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<!-- Origin Trial Token, feature = WebVR (For Chrome M62+), origin = https://threejs.org, expires = 2018-01-21 -->
		<meta http-equiv="origin-trial" data-feature="WebVR (For Chrome M62+)" data-expires="2018-01-21" content="Ap+tmQjuEXRrzmu+ZuReB/eY8fZmTEOybJ2hME1RgEZAPzhZ4/IAKEHRebiTp6o4LoZOMBexL4GAL7flIkAUlQYAAABQeyJvcmlnaW4iOiJodHRwczovL3RocmVlanMub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJWUjEuMU02MiIsImV4cGlyeSI6MTUxNjUzODYxMX0=">
		<style>
			body {
				font-family: Monospace;
				background-color: #101010;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			a {
				color: #f00;
			}
		</style>
	</head>
	<body>

		<script src="./js/three.js"></script>
		<script type="text/javascript" src="js/stats.js"></script>
		<script type="text/javascript" src="js/scene.js"></script>
		<script type="text/javascript" src="./js/phys/physi.js"></script>

		<script src="./js/ViveController.js"></script>
		<script src="./js/PaintViveController.js"></script>
		<script src="./js/MoveViveController.js"></script>
		<script src="./js/BasicViveController.js"></script>
		<script src="./js/DragViveController.js"></script>
		<script src="./js/WebVR.js"></script>
		
		<script src="./js/OBJLoader.js"></script>
		<script src="./js/MTLLoader.js"></script>

		<script>
			'use strict';
	
			Physijs.scripts.worker = '/js/phys/physijs_worker.js';
			Physijs.scripts.ammo = '/js/phys/ammo.js';
	
			var container;

			var camera, scene, renderer;
			var user;
			var basic_model,basic_controller;
			var controller1, controller2;
			var handleController;
			var controller_offset_z = -0.07;
			var controller_offset_y = 0.03;
			handleController = function( controller ) {}	//start off with nothing
			//for dragcontroller
			var intersected = [];
			var raycaster = new THREE.Raycaster();
			var tempMatrix = new THREE.Matrix4();
			var group = THREE.Group();

			var block_material, block_geometry;
			var phys_obj1, phys_obj2;
			var obj_list = [];
			
			var load_model;
			var line;
			var shapes = {};
			var createTower;
			
			var up = new THREE.Vector3( 0, 1, 0 );
			var vector = new THREE.Vector3();
			var vector1 = new THREE.Vector3();
			var vector2 = new THREE.Vector3();
			var vector3 = new THREE.Vector3();
			var vector4 = new THREE.Vector3();
			var point4 = new THREE.Vector3();
			var point5 = new THREE.Vector3();

			window.onload = init();
			var render_stats, physics_stats;
			
			function init_stats(){
				render_stats = new Stats();
				render_stats.domElement.style.position = 'absolute';
				render_stats.domElement.style.top = '1px';
				render_stats.domElement.style.zIndex = 100;
				container.appendChild( render_stats.domElement );
				physics_stats = new Stats();
				physics_stats.domElement.style.position = 'absolute';
				physics_stats.domElement.style.top = '50px';
				physics_stats.domElement.style.zIndex = 100;
				container.appendChild( physics_stats.domElement );
			}
			function init_info(){
				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - htc vive - paint';
				container.appendChild( info );
			}
			function init() {

				
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				init_stats();
				init_info();
				load_materials();

				scene = new Physijs.Scene;
				// scene = new Physijs.Scene({ fixedTimeStep: 1 / 0 });
				scene.setGravity(new THREE.Vector3( 0, -10, 0 ));
				scene.background = new THREE.Color( 0x222222 );

				user = new THREE.Group();
				user.position.set( 0, 1.6, 0 );
				scene.add( user );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 50 );
				user.add( camera );

				
				create_scene_objects();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.shadowMap.enabled = true;
				renderer.vr.enabled = true;	//VR REQUIRED
				container.appendChild( renderer.domElement );

				document.body.appendChild( WEBVR.createButton( renderer ) ); //VR REQUIRED

				// controllers

				controller1 = new THREE.BasicViveController( 0 );
				controller1.userData.points = [ new THREE.Vector3(), new THREE.Vector3() ];
				controller1.userData.matrices = [ new THREE.Matrix4(), new THREE.Matrix4() ];
				user.add( controller1 );

				controller2 = new THREE.BasicViveController( 1 );
				controller2.userData.points = [ new THREE.Vector3(), new THREE.Vector3() ];
				controller2.userData.matrices = [ new THREE.Matrix4(), new THREE.Matrix4() ];
				user.add( controller2 );
				
				load_basic_model(basic_model);
				controller1.addEventListener( 'menudown', on_menu_up );
				controller2.addEventListener( 'menudown', on_menu_up );
				initGeometry();
				createTower(30);
				//Add physics object so controllers actually interact with scene. 
				// Can't simply parent controllers because phys sim needs specific pos updating
				
				var physGeom = new THREE.CubeGeometry(0.12, 0.1, 0.22); //makes box around controller
				
				var physMaterial = new Physijs.createMaterial(new THREE.MeshBasicMaterial({}), 0.5, 0.5);
				physMaterial.visible = false;	//THis is the part that does the work
				phys_obj1 = new Physijs.BoxMesh(physGeom, physMaterial, 100);
				phys_obj2 = new Physijs.BoxMesh(physGeom, physMaterial, 100);
				//offsets to center of controller
				scene.add(phys_obj1);
				scene.add(phys_obj2);
				obj_list = [phys_obj1,phys_obj2];
				// Start simulation
				window.addEventListener( 'resize', onWindowResize, false );
				requestAnimationFrame( render );
				scene.simulate();
			}	
			var current_controller = 0;
			var ncontrollers = 3;
			var last_menu_state = false;
			function on_menu_up(){
					// createTower(100);
					user.remove(controller1);
					user.remove(controller2);
					console.log("menu pressed");
					current_controller++;
					if(current_controller == ncontrollers){
						current_controller = 0;
					}
					if(current_controller == 0){
						controller1 = new THREE.PaintViveController( 0 );
						controller2 = new THREE.PaintViveController( 1 );
						//console.log("switched to paint mode");
					}
					
					if(current_controller == 1){
						controller1 = new THREE.MoveViveController( 0 );
						controller2 = new THREE.MoveViveController( 1 );
						//console.log("switched to move mode");
					}

					if(current_controller == 2){
						controller1 = new THREE.DragViveController( 0 );
						controller2 = new THREE.DragViveController( 1 );
					}
					
					controller1.userData.points = [ new THREE.Vector3(), new THREE.Vector3() ];
					controller1.userData.matrices = [ new THREE.Matrix4(), new THREE.Matrix4() ];
					user.add( controller1 );
					controller2.userData.points = [ new THREE.Vector3(), new THREE.Vector3() ];
					controller2.userData.matrices = [ new THREE.Matrix4(), new THREE.Matrix4() ];
					user.add( controller2 );
					load_model(controller1);
					load_model(controller2);

					
					
					controller1.addEventListener( 'menuup', on_menu_up );
					controller2.addEventListener( 'menuup', on_menu_up );	
			}

			function update_phys_objects(){
				var user_pos = user.position;
				//First controller
				var c1rot = controller1.rotation;
			    phys_obj1.rotation.set(c1rot.x, c1rot.y, c1rot.z);
    			phys_obj1.__dirtyRotation = true;

				
				var c1pos = controller1.position;
				phys_obj1.position.set( c1pos.x +user_pos.x, c1pos.y +user_pos.y + controller_offset_y, c1pos.z +user_pos.z );
			    phys_obj1.__dirtyPosition = true;

			    
			    // You may also want to cancel the object's velocity
			    phys_obj1.setLinearVelocity(new THREE.Vector3(0, 0, 0));
			    phys_obj1.setAngularVelocity(new THREE.Vector3(0, 0, 0));

			   	//second contrdoller
			   	 var c2rot = controller2.rotation;
			    phys_obj2.rotation.set(c2rot.x, c2rot.y, c2rot.z);
    			phys_obj2.__dirtyRotation = true;

			    var c2pos = controller2.position;
				phys_obj2.position.set( c2pos.x +user_pos.x, c2pos.y +user_pos.y + controller_offset_y, c2pos.z +user_pos.z );
			    phys_obj2.__dirtyPosition = true;

			   

			    // You may also want to cancel the object's velocity
			    phys_obj2.setLinearVelocity(new THREE.Vector3(0, 0, 0));
			    phys_obj2.setAngularVelocity(new THREE.Vector3(0, 0, 0));


			}
			function render() {

				var count = line.geometry.drawRange.count;
				update_phys_objects();
				handleController( controller1 );
				handleController( controller2 );

				updateGeometry( count, line.geometry.drawRange.count );
				scene.simulate(); // run physics
				requestAnimationFrame( render );
				renderer.render( scene, camera );
				render_stats.update();
				physics_stats.update();
			}

		</script><div><div style="position: absolute; top: 10px; width: 100%; text-align: center;"><a href="http://threejs.org/" target="_blank" rel="noopener">three.js</a> webgl - htc vive - paint</div><canvas width="3024" height="1680" style="width: 1280px; height: 918px;"></canvas></div>
	

</body></html>